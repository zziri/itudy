# 해싱
키 값에 산술적인 연산을 통해 키에 대한 고유한 인덱스를 생성하고 이 인덱스를 활용하여 값을 활용하여 값을 탐색 or 저장하는 것

* 해시함수: 키 값을 인자로받아 인덱스(해시주소)를 생성하는 함수
* 버켓: 실제 값이 저장되는 장소, 해시함수를 거쳐 생성된 인덱스로 접근 가능

## 해시함수
해시테이블에서 키 값을 이용하여 고유한 인덱스(해시주소)를 생성하는 함수

**좋은 해시함수의 조건**
	* 충돌이 적게 발생
	* 해시주소가 고르게 분포되어야 됨
	* 해시 함수의 연산이 빨라야함

**종류**
1. 나머지 연산을 이용한 함수
테이블의 크기가 M이고 키 값이 k일때 ```h(k) = k % M```
(이때 M은 반드시 소수여야만 함)

```
public static final int M; // 해시 값(해시테이블 크기, prime number)

int hashFunc(int key)
{
	int hashIndex = key % M;
	if(hashIndex < 0) hashIndex *= -1;
	return hashIndex
}
```

2. 폴딩
키 값을 여러 부분으로 나누어 특정 연산을 거쳐 인덱스를 생성하는 방법

	ex) 키 값이 203,471,645,23인경우
	이동 폴딩: 203 + 471 + 645 + 23 = 1342
	경계 폴딩: 203 + 174 + 645 + 32 = 1024


## 해시의 충돌(collision)
다른 키 값을 가지지만 해시함수를 거쳐 얻은 인덱스 값이 같은 경우를 충돌이라고 하며, 이 경우 이미 해당 해시주소가 사용되는 상황이기 때문에 이를 해결할 방법을 구상해야 한다.

### 충돌해결
**분리 연결법(Separate Chaining)**
버켓에 연결리스트 등의 자료구조를 이용하여 동일 버켓에 하나 이상의 값을 저장할 수 있도록 구현
![separate chaining](https://github.com/zziri/itudy/blob/master/image/)



**개방 주소법(Open Addressing)**
충돌이 발생하면 해시테이블에서 빈 버켓을 찾는 방법
1) 선형조사법(linear probing): 현재 버켓 인덱스로부터 일정 값(n)만큼 증가시켜 빈 버켓을 찾는 방법
**h(k) % M -> h(k) + 1 % M -> h(k) + 2 % M -> ''''''**
이때 ```h(k) % M == h(k) + n % M``` 이면 해시 테이블이 가득찬 것

2) 이차조사법(quardraitc probing): 선형 조사법과 비슷하지만 증가량이 제곱
**h(k) % M -> h(k) + 1^2 % M -> h(k) + 2^2 % M -> ''''''**

*Open Addressing을 진행하다가 해시테이블이 가득찬 경우 리사이징을 하는데 threshold는 현재 버켓의 75%정도이며 load factor로 불린다. 보통 2배 크기로 리사이징하며 기존버켓의 저장되어 있는 것들을 해시함수를 거쳐 다시 새로운 해시테이블에 복사

3) 이중해시법: 충돌 발생시 원래 해시함수와 다른 별개의 함수를 이용하여 인덱스를 찾는 방법, 다시 함수를 통해 인덱스를 생성하기 때문에 연산량이 증가
