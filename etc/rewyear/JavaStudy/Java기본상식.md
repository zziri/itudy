## 자바 가상 머신(JVM)
시스템 메모리를 관리하면서, 자바 애플리케이션을 위해 이식 가능한 환경을 제공함   
* 자바 프로그램이 어느 OS에서나 실행될 수 있도록 하는 것
  
* 프로그램 메모리를 관리하고 최적화하는 것
  * 프로그램이 실행되면 OS로부터 프로그램이 필요로 하는 메모리를 할당 받고, 이를 용도에 따라 여러 섹션으로 나누어 관리
  * 클래스 로더를 통해 컴파일러가 컴파일한 바이트코드(.class)을 메모리에 로딩
  * 로딩된 클래스 파일들은 실행 엔진에서 해석되고, 메모리 영역에 배치되어 실질적인 동작 수행
  * 스레드 동기화나, 가비지 컬렉션 같은 메모리 관리 작업 수행


#### 자바 컴파일 과정
작성한 .java 소스파일을 컴파일러가 컴파일 하여 .class(자바 바이트코드) 생성   
이후 JVM 클래스로더가 동적로딩
	컴파일한 .class 와 실행에 필요한 클래스 라이브러리 파일을 로딩 및 링킹   

실행엔진은 JVM메모리에 로딩된 바이트 코드들을 하기 두 가지 방법들로 실행   
1. 인터프리터 방식: 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
2. JIT 컴파일러 방식: 바이트 코드 전체를 컴파일 하여 바이너리 코드 생성 후 더 이상 바이트 코드를을 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식

* * *

## Java에서의 Call by value / Call by reference
기존 C / C++ 에서의 Call by value / Call by reference과는 다르게 Java에서는 주소 값 자체를 가져올 방법이 없으므로
java에서 함수의 매개변수로 call by value를 통해 값을 전달한다. 참조 자료형을 전달할 때에는 해당 객체의 주소 값을 복사하여 이를 사용한다.

이에 대한 이해를 위해서는 먼저 자바의 변수 생성 과정을 이해해야 한다.   
하기 예제는 이해를 돕기 위한 코드이다.   

```
int a = 10;
b = a;

// 10이라는 값의 주소값을 가지고 있음.
System.out.println(System.identityHashCode(a));
System.out.println(System.identityHashCode(b));

// 11이라는 값의 생성되어 메모리에 할당
a = 11;

// a는 값 11의 메모리 주소를 가리키고 있음
System.out.println(System.identityHashCode(a));
System.out.println(System.identityHashCode(b));

```
-> java에서는 생성한 변수 마다 메모리 공간을 갖지만
해당 메모리 공간에 값 자체를 저장하는 것이 아니라, 값이 저장된 메모리 공간의 주소값을 저장한다.

<!---
```
Name aaa = new Name("aaa"); // Name객체 생성 및 aaa에 할당

test(aaa); // test()호출 시 매개 변수에 aaa의 주소를 저장

public void test(Name bbb)
{
	bbb = new User("bbb"); // 함수 내부에서 
}
```
--->

