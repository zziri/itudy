
## 1. Round Robin 스케줄링 정책을 따르고 CPU burst 작업만 있는 A, B, C 프로세스가 Ready Queue에 순서대로 들어간 상태일 때 실제 동작을 설명하세요

### 답안 :


- A가 100ms동안 실행되고 Ready Queue에 들어간다
- B가 위와 같은 방식으로 실행된다
- C가 위와 같은 방식으로 실행된다
- A가 100ms동안 실행되고 종료한다
- B가 100ms 동안 실행되고 Ready Queue에 들어간다
- C가 위와 같은 방식으로 실행된다
- B가 위와 같은 방식으로 실행된다
- C가 100ms 동안 실행되고 종료한다
- B가 100ms 동안 실행되고 Running Queue에 그대로 존재한다
- B가 100ms 동안 실행되고 종료한다

## 2. 페이징을 기반으로 하며 요구 페이징을 지원하고 MMU, TLB 칩이 내장된 시스템일때 CPU 상에서 가상 주소로 메모리에서 데이터를 가져와야 할때, 실제 동작을 설명하세요

### 답안 :


- CPU에서 Virtual Address(Logical Address)를 요청
- TLB에 저장되어있는지(캐싱되어있는지) 확인하고 있다면 해당 물리주소를 바로 read
- TLB에 없다면 페이지 테이블을 참조해서 물리 메모리의 frame index와 offset을 read
- 페이지 테이블을 참조했는데 해당 페이지가 invalid라서 page fault가 발생하면 해당 페이지를 메모리에 올림(swap in)
- MMU를 통해 physical address로 변환하고 이 값을 TLB에 저장
- 얻은 physical address로 실제 메모리에서 data read


## 3. 사용자가 컴퓨터를 켰을 때, 쉘을 실행할 때까지 동작을 설명하세요

### 답안 :


- 처음 CPU에 전원이 들어오면 CPU의 PC는 ROM(혹은 다른 종류의 메모리)에 저장되어있는 BIOS의 처음 시작 주소가 저장되어있다. PC에 BIOS의 시작주소가 저장되어있으므로 BIOS가 실행된다
- BIOS가 실행되면서 디스크(SSD, HDD, …)에 저장되어있는 MBR을 읽어 메모리에 load한다
- MBR은 부트섹터가 저장된 위치를 알고있으며 부트섹터를 메모리에 로드한다
- 부트 섹터가 커널 이미지를 메모리에 로드하고 PC에 커널의 시작 주소를 저장해둠으로써 이후 OS가 실행되도록 한다
- OS가 실행되고 나서 fork(), exec() 등의 동작으로 쉘 프로그램이 실행된다


4. 커맨드 창에서 ls(dir) 명령을 키보드로 작성할 때, 실제 동작을 설명하세요

### 답안 :


- 사용자가 l, s 키를 누를때마다 인터럽트가 발생하고 터미널에 해당 문자가 표시가 된다
- 사용자가 엔터키를 누르면 인터럽트가 발생해서 터미널을 통해 쉘로 ls 명령어가 전달되며 ls 프로그램을 실행시킨다
- ls 프로그램을 실행하면 파라미터를 받아들여(여기서는 현재 경로) 파일 시스템에 접근하기 위해서 시스템 콜을 하여 커널 모드로 동작한다
- 커널 모드에서는 ‘/’ dentry부터 시작해서 현재 경로에 해당하는 dentry까지 찾는다
- 찾은 dentry의 inode structure의 Blocks를 통해 어떤 파일 혹은 디렉토리가 있는지 읽는다
- 읽은 결과를 반환하면서 유저모드로 전환된다
- 결과값을 stdout stream에 write한다
- 터미널에 결과값이 출력되며 ls 프로그램이 종료된다

