# HTTPS

그림으로 배우는 HTTP & Network - HTTPS

## HTTP의 약점

### 평문이기 때문에 도청 가능

TCP/IP는 도청이 가능한 네트워크입니다. 와이어샤크를 이용해서 HTTP의 메세지 내용이 전부 확인할 수 있습니다.

통신 자체를 암호화하는 방법으로 도청을 피할 수 있습니다. HTTP에는 암호화 구조가 없지만 SSL(Secure Socket Layer), TLS(Transport Layer Security) 등의 프로토콜을 조합해서 암호화가 가능합니다. SSL을 조합한 HTTP를 HTTPS라고 부릅니다.

두 번째 방법으로는 메세지 바디에 들어가는 콘텐츠 자체를 암호화해서 도청을 피할 수 있습니다. 다만 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 가지고 있어야 하므로 주로 웹 서비스에서만 이용됩니다.

### 통신 상대를 확인하지 않기 때문에 위장이 가능

누구나 서버에 리퀘스트를 할 수 있습니다. 서버는 하는 통신 상대가 누구인지 모르므로 리퀘스트를 거부하지 않습니다.

상대를 확인하는 증명서를 이용해서 위장을 식별할 수 있습니다. 이때는 SSL 프로토콜을 이용해야 합니다. 증명서는 신뢰할 수 있는 제 3기관에서 발급합니다.

### 완전성을 증명할 수 없기 때문에 변조 가능

서버로부터 혹은 클라이언트로부터 수신한 내용이 중간에 변조되었을 가능성이 있습니다. 공격자가 중간에서 데이터를 변조하면 이런 현상이 벌어질 수 있습니다.

현재로서는 변조를 완벽히 막을 방법은 HTTP을 사용하는 경우에서는 없습니다. 널리 사용되는 방법은 MD5나 SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법입니다.

가장 확실한 방법은 HTTPS를 사용해야 합니다. SSL자체에 인증, 암호화 기능을 제공하기 때문입니다.

## HTTPS

### HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS

HTTP는 평문으로 통신합니다. 이 때문에 발생하는 위장, 변조, 도청 등의 문제를 해결하기 위해서 HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure)라고 부릅니다.

### HTTPS는 SSL의 껍질을 덮어쓴 HTTP

HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니고 HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security) 프로토콜로 대체합니다. 즉 HTTP 프로토콜의 일부를 SSL이나 TLS로 대체합니다.

### 상호간에 키를 교환하는 공개키 암호화 방식

SSL 통신할 때 공개키를 이용해 암호화를 합니다. 보통 공개키와 비밀키를 함께 사용하고 공개키는 공개되어 있으며 공개키를 사용해서 데이터를 암호화하고 비밀키를 이용해서 암호화된 데이터를 복호화합니다. 비밀키는 로컬에서만 존재하고 전송하지 않으므로 누군가에게 알려질 위험이 없습니다.

### 공개키가 정확한지 아닌지를 증명하는 증명서

공개키 암호에도 문제점이 있습니다. 공개키가 진짜인지 아닌지 증명할 수 없다는 것입니다.

이 문제를 해결하기 위해서 인증 기관과 그 기관이 발행하는 공개키 증명서가 이용되고 있습니다. 인증 기관은 서버와 클라이언트 모두 신뢰하는 제 3의 기관입니다.

유명한 인증 기관의 증명서는 대개 브라우저에 내장된 상태로 제품이 배포됩니다.

## 왜 항상 HTTPS를 사용하지 않을까

HTTPS를 사용하게 되면 암호화, 복호화 연산이 필요하고 키와 증명서 등을 추가적으로 전송해야 하기 때문에 속도가 느립니다. 이것을 해결하기 위한 SSL 엑셀러레이터라는 하드웨어가 있지만 비용이 발생하고 증명서를 구입해야 하는 부분에서도 비용이 발생하기 때문에 항상 HTTPS를 사용하는 것은 무리가 될 수 있습니다.



# 인증

그림으로 배우는 HTTP & Network - 인증

## 인증이란

액세스하고 있는 상대가 누군지 알 수 있는 방법입니다

HTTP에서는 주로 다음의 방법으로 인증을 합니다

- BASIC 인증
- DIGEST 인증
- SSL 클라이언트 인증
- 폼 베이스 인증

## BASIC 인증

다음과 같은 인증 수순을 거칩니다

1. 리퀘스트 송신 - 클라이언트
2. 상태 코드 401로 응답 - 서버
3. 유저 ID와 패스워드를 Base64 형식으로 인코드해서 송신 - 클라이언트
4. 인증 성공하면 200, 실패하면 다시 401로 응답 - 서버

Base64는 암호화된 코드를 아무런 부가 정보 없이 복호화가 가능합니다. 즉, 암호화되지 않은 통신 경로 상에서 BASIC 인증을 해서 도청된 경우에는 복호화된 유저 ID와 패스워드를 빼앗길 가능성이 있습니다. 또한 일반 브라우저에서는 한번 인증하면 로그아웃할 수 없다는 문제점도 있습니다.

결론적으로 잘 사용하지 않는 인증입니다

## DIGEST 인증

다음과 같은 인증 수순을 거칩니다

1. 리퀘스트 송신 - 클라
2. 인증이 필요하다는 401 응답과 함께 패스워드와 챌린지 코드(nonce)를 송신 - 서버
3. 패스워드와 챌린지 코드에서 리스폰스 코드(response)를 계산해서 송신 - 클라
4. 인증 성공 시에 200 응답, 실패하면 다시 401 송신 - 서버

