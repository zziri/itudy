# HTTPS

그림으로 배우는 HTTP & Network - HTTPS

## HTTP의 약점

### 평문이기 때문에 도청 가능

TCP/IP는 도청이 가능한 네트워크입니다. 와이어샤크를 이용해서 HTTP의 메세지 내용이 전부 확인할 수 있습니다.

통신 자체를 암호화하는 방법으로 도청을 피할 수 있습니다. HTTP에는 암호화 구조가 없지만 SSL(Secure Socket Layer), TLS(Transport Layer Security) 등의 프로토콜을 조합해서 암호화가 가능합니다. SSL을 조합한 HTTP를 HTTPS라고 부릅니다.

두 번째 방법으로는 메세지 바디에 들어가는 콘텐츠 자체를 암호화해서 도청을 피할 수 있습니다. 다만 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 가지고 있어야 하므로 주로 웹 서비스에서만 이용됩니다.

### 통신 상대를 확인하지 않기 때문에 위장이 가능

누구나 서버에 리퀘스트를 할 수 있습니다. 서버는 하는 통신 상대가 누구인지 모르므로 리퀘스트를 거부하지 않습니다.

상대를 확인하는 증명서를 이용해서 위장을 식별할 수 있습니다. 이때는 SSL 프로토콜을 이용해야 합니다. 증명서는 신뢰할 수 있는 제 3기관에서 발급합니다.

### 완전성을 증명할 수 없기 때문에 변조 가능

서버로부터 혹은 클라이언트로부터 수신한 내용이 중간에 변조되었을 가능성이 있습니다. 공격자가 중간에서 데이터를 변조하면 이런 현상이 벌어질 수 있습니다.

현재로서는 변조를 완벽히 막을 방법은 HTTP을 사용하는 경우에서는 없습니다. 널리 사용되는 방법은 MD5나 SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법입니다.

가장 확실한 방법은 HTTPS를 사용해야 합니다. SSL자체에 인증, 암호화 기능을 제공하기 때문입니다.

## HTTPS

### HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS

HTTP는 평문으로 통신합니다. 이 때문에 발생하는 위장, 변조, 도청 등의 문제를 해결하기 위해서 HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure)라고 부릅니다.

### HTTPS는 SSL의 껍질을 덮어쓴 HTTP

HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니고 HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security) 프로토콜로 대체합니다. 즉 HTTP 프로토콜의 일부를 SSL이나 TLS로 대체합니다.

### 상호간에 키를 교환하는 공개키 암호화 방식

SSL 통신할 때 공개키를 이용해 암호화를 합니다. 보통 공개키와 비밀키를 함께 사용하고 공개키는 공개되어 있으며 공개키를 사용해서 데이터를 암호화하고 비밀키를 이용해서 암호화된 데이터를 복호화합니다. 비밀키는 로컬에서만 존재하고 전송하지 않으므로 누군가에게 알려질 위험이 없습니다.

### 공개키가 정확한지 아닌지를 증명하는 증명서

공개키 암호에도 문제점이 있습니다. 공개키가 진짜인지 아닌지 증명할 수 없다는 것입니다.

이 문제를 해결하기 위해서 인증 기관과 그 기관이 발행하는 공개키 증명서가 이용되고 있습니다. 인증 기관은 서버와 클라이언트 모두 신뢰하는 제 3의 기관입니다.

유명한 인증 기관의 증명서는 대개 브라우저에 내장된 상태로 제품이 배포됩니다.

## 왜 항상 HTTPS를 사용하지 않을까

HTTPS를 사용하게 되면 암호화, 복호화 연산이 필요하고 키와 증명서 등을 추가적으로 전송해야 하기 때문에 속도가 느립니다. 이것을 해결하기 위한 SSL 엑셀러레이터라는 하드웨어가 있지만 비용이 발생하고 증명서를 구입해야 하는 부분에서도 비용이 발생하기 때문에 항상 HTTPS를 사용하는 것은 무리가 될 수 있습니다.



# 인증

그림으로 배우는 HTTP & Network - 인증

## 인증이란

액세스하고 있는 상대가 누군지 알 수 있는 방법입니다

HTTP에서는 주로 다음의 방법으로 인증을 합니다

- BASIC 인증
- DIGEST 인증
- SSL 클라이언트 인증
- 폼 베이스 인증

## BASIC 인증

다음과 같은 인증 수순을 거칩니다

1. 리퀘스트 송신 - 클라이언트
2. 상태 코드 401로 응답 - 서버
3. 유저 ID와 패스워드를 Base64 형식으로 인코드해서 송신 - 클라이언트
4. 인증 성공하면 200, 실패하면 다시 401로 응답 - 서버

Base64는 암호화된 코드를 아무런 부가 정보 없이 복호화가 가능합니다. 즉, 암호화되지 않은 통신 경로 상에서 BASIC 인증을 해서 도청된 경우에는 복호화된 유저 ID와 패스워드를 빼앗길 가능성이 있습니다. 또한 일반 브라우저에서는 한번 인증하면 로그아웃할 수 없다는 문제점도 있습니다.

결론적으로 잘 사용하지 않는 인증입니다

## DIGEST 인증

다음과 같은 인증 수순을 거칩니다

1. 리퀘스트 송신 - 클라
2. 인증이 필요하다는 401 응답과 함께 패스워드와 챌린지 코드(nonce)를 송신 - 서버
3. 패스워드와 챌린지 코드에서 리스폰스 코드(response)를 계산해서 송신 - 클라
4. 인증 성공 시에 200 응답, 실패하면 다시 401 송신 - 서버

결론적으로 BASIC 인증과 같이 보안 등급에도 미치지 못하고 잘 사용하지 않는 인증입니다

## SSL 클라이언트 인증

유저 ID와 패스워드를 이용한 인증 방식은 본인으로서 인증할 수 있습니다. 하지만 이 정보가 도난되었을 때에는 제 3자가 위장할 수 있으므로 대책이 필요합니다. 이 대책 중 하나로 SSL 클라이언트 인증이 사용되는 일이 있습니다.

이 인증은 HTTPS의 클라이언트 인증서를 이용한 인증 방식입니다. 사전에 등록된 클라이언트에서의 액세스인지 아닌지 판단할 수 있습니다.

다음과 같은 인증 수순을 거칩니다

1. 인증이 필요한 리소스의 리퀘스트 - 클라
2. 클라이언트 증명서를 요구하는 Certificate Request 메세지 전송 - 서버
3. 인증서와 함께 Client Certificate 메세지 송신 - 클라
4. 증명서를 검증하고 맞다면 클라이언트의 공개키를 취득, 이후 HTTPS에 의한 암호 개시 - 서버

SSL 클라이언트 인증은 2-factor 인증에서 사용됩니다. 폼 베이스 인증과 합쳐서 사용하는 방법입니다.

SSL 클라이언트 검증은 이용하는데 비용이 발생합니다. 인증 기관에서 증명서를 구입하는 비용이나 서버의 운영자 자신이 인증 기관을 만들어서 안전하게 운용하기 위해 들어가는 비용입니다.

## 폼 베이스 인증

사전에 등록해둔 유저 ID와 패스워드를 입력해서 이것을 웹 애플리케이션에 송신하고 검증 결과를 토대로 검증 성공 여부를 결정합니다

인증의 대부분은 폼 베이스 인증입니다. HTTP가 표준으로 제공하는 BASIC, DIGEST 인증은 사용상의 문제와 보안적인 문제로 거의 사용되지 않고 SSL 클라이언트 인증 방식은 비용이 발생합니다. 폼 베이스 인증은 표준이 아니고 웹 애플리케이션에서 제각각 구현하는 폼 베이스 인증을 채용합니다.

폼 베이스 인증은 표준은 없지만 일반적으로 세션 관리를 위해서 쿠키를 사용하는 방법이 있습니다. HTTP는 스테이트리스 프로토콜이기 때문에 인증을 성공했던 유저라는 상태를 프로토콜 레벨에서 유지할 수 없습니다. 그래서 세션 관리와 쿠리를 사용하여 상태 관리 기능을 보충합니다.

대표적인 구현 예로 다음과 같은 수순을 거칩니다

1. 유저 ID와 패스워드를 포함한 리퀘스트 송신, POST 메소드가 사용되어 엔티티 바디에 저장, HTML 폼 화면 표시와 입력 데이터의 송신에는 HTTPS 통신을 이용 - 클라
2. "Set-Cookie" 헤더 필드에 세션 ID를 저장해서 리스폰스 반환 - 서버
3. 세션 ID를 쿠키로 저장, 이후 리퀘스트를 송신할 때에 브라우저가 자동으로 쿠키를 송출




